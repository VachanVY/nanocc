; ----------- IR Generation -----------
; IRProgram(
;   Function(
;     name='main'
;     instructions=[
;       sum.0 = 0
;       i.1 = 0
;     start_for.0:
;       tmp.2 = i.1 < 10
;       jump_if_zero tmp.2, break_for.0
;       tmp.3 = i.1 + 1
;       i.1 = tmp.3
;       tmp.4 = i.1 % 2
;       jump_if_zero tmp.4, end.1
;       jump continue_for.0
;     end.1:
;       tmp.5 = sum.0 + i.1
;       sum.0 = tmp.5
;     continue_for.0:
;       jump start_for.0
;     break_for.0:
;       return sum.0
;       return 0
;     ]
;   )
; )
; -------------------------------------


    .globl main
main:
    pushq %rbp
    movq %rsp, %rbp
    subq $24, %rsp
    movl $0, -4(%rbp) # sum = 0
    movl $0, -8(%rbp) # i = 0
  start_for.0:
    cmpl $10, -8(%rbp) # compare i and 10
    movl $0, -12(%rbp) # mov 0 to temp
    # the l here means less than
    setl -12(%rbp)     # if i was less than 10; set it to 1
    cmpl $0, -12(%rbp) # compare 0 and temp
    je break_for.0     # if temp is 0, jump to break_for.0
    movl -8(%rbp), %r10d # load i to r10d
    movl %r10d, -16(%rbp) # move i to temp
    addl $1, -16(%rbp) # temp = temp + 1
    movl -16(%rbp), %r10d # move temp to r10d
    movl %r10d, -8(%rbp)  # move temp to i
    movl -8(%rbp), %eax # i is the dividend
    cdq                 # sign extend eax to edx:eax  
    movl $2, %r10d      # 2 is divisor
    idivl %r10d         # edx = remainder, eax = quotient
    movl %edx, -20(%rbp) # remainder stored in edx
    cmpl $0, -20(%rbp)   # compare remainder and 0
    je end.1             # if remainder is 0, jump to end.1
    jmp continue_for.0   # if remainder is 1, jump to continue_for.0
  end.1: # sum = sum + i
    movl -4(%rbp), %r10d # load sum to r10d
    movl %r10d, -24(%rbp) # move sum to temp
    movl -8(%rbp), %r10d # load i to r10d
    addl %r10d, -24(%rbp) # temp = temp + i
    movl -24(%rbp), %r10d # move temp to r10d
    movl %r10d, -4(%rbp) # update sum
  continue_for.0:
    jmp start_for.0 # jump to start_for.0
  break_for.0:
    movl -4(%rbp), %eax # return sum
    movq %rbp, %rsp
    popq %rbp
    ret
    movl $0, %eax
    movq %rbp, %rsp
    popq %rbp
    ret
    .section .note.GNU-stack, "",@progbits

# Assembly generated by GCC
; 	.file	"asm.c"
; 	.text
; 	.globl	main
; 	.type	main, @function
; main:
; .LFB0:
; 	.cfi_startproc
; 	endbr64
; 	pushq	%rbp
; 	.cfi_def_cfa_offset 16
; 	.cfi_offset 6, -16
; 	movq	%rsp, %rbp
; 	.cfi_def_cfa_register 6
; 	movl	$0, -8(%rbp)
; 	movl	$0, -4(%rbp)
; 	jmp	.L2
; .L4:
; 	addl	$1, -4(%rbp)
; 	movl	-4(%rbp), %eax
; 	andl	$1, %eax
; 	testl	%eax, %eax
; 	je	.L3
; 	jmp	.L2
; .L3:
; 	movl	-4(%rbp), %eax
; 	addl	%eax, -8(%rbp)
; .L2:
; 	cmpl	$9, -4(%rbp)
; 	jle	.L4
; 	movl	-8(%rbp), %eax
; 	popq	%rbp
; 	.cfi_def_cfa 7, 8
; 	ret
; 	.cfi_endproc
; .LFE0:
; 	.size	main, .-main
; 	.ident	"GCC: (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0"
; 	.section	.note.GNU-stack,"",@progbits
; 	.section	.note.gnu.property,"a"
; 	.align 8
; 	.long	1f - 0f
; 	.long	4f - 1f
; 	.long	5
; 0:
; 	.string	"GNU"
; 1:
; 	.align 8
; 	.long	0xc0000002
; 	.long	3f - 2f
; 2:
; 	.long	0x3
; 3:
; 	.align 8
; 4:
